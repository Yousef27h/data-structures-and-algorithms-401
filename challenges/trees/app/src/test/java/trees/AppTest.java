/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package trees;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import trees.binaryTree.BinaryTree;
import trees.data.Node;

import java.util.ArrayList;
import java.util.Arrays;

import static org.junit.jupiter.api.Assertions.*;

class AppTest {

    // Can successfully instantiate an empty tree
    @Test void emptyTest(){
        BinaryTree<Integer> binaryTree = new BinaryTree<>();
        assertEquals(null, binaryTree.getRoot());
    }
    //Can successfully instantiate a tree with a single root node
    @Test void singleRootTest(){
        BinaryTree<Integer> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new Node<>(1));
        assertEquals(1, binaryTree.getRoot().getKey());
    }
    //Can successfully add a left child and right child to a single root node
    @Test void  addChildTest(){
        BinaryTree<Integer> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new Node<>(1));
        binaryTree.getRoot().setLeftChild(new Node<>(2));
        binaryTree.getRoot().setRightChild(new Node<>(3));
        assertEquals(2, binaryTree.getRoot().getLeftChild().getKey());
        assertEquals(3, binaryTree.getRoot().getRightChild().getKey());
    }
    //Can successfully return a collection from a preorder traversal
    @Test void preOrderTest(){
        BinaryTree<Integer> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new Node<>(1));
        binaryTree.getRoot().setLeftChild(new Node<>(2));
        binaryTree.getRoot().setRightChild(new Node<>(3));
        ArrayList<Integer> arr = new ArrayList<>();
        arr.add(1);
        arr.add(2);
        arr.add(3);
        assertEquals(arr, binaryTree.preOrder(binaryTree.getRoot()));
    }
    //Can successfully return a collection from a postorder traversal
    @Test void postOrderTest(){
        BinaryTree<Integer> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new Node<>(1));
        binaryTree.getRoot().setLeftChild(new Node<>(2));
        binaryTree.getRoot().setRightChild(new Node<>(3));
        ArrayList<Integer> arr = new ArrayList<>();
        arr.add(2);
        arr.add(3);
        arr.add(1);
        assertEquals(arr, binaryTree.postOrder(binaryTree.getRoot()));
    }
    //Can successfully return a collection from an inorder traversal
    @Test void inOrderTest(){
        BinaryTree<Integer> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new Node<>(1));
        binaryTree.getRoot().setLeftChild(new Node<>(2));
        binaryTree.getRoot().setRightChild(new Node<>(3));
        ArrayList<Integer> arr = new ArrayList<>();
        arr.add(2);
        arr.add(1);
        arr.add(3);
        assertEquals(arr, binaryTree.inOrder(binaryTree.getRoot()));
    }
}

class maxTest{
    // Finds the maximum value stored in the tree.
    @Test void maxTest(){
        BinaryTree<Integer> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new Node<>(1));
        binaryTree.getRoot().setLeftChild(new Node<>(2));
        binaryTree.getRoot().setRightChild(new Node<>(3));
        assertEquals(3, binaryTree.maxValue());
    }
    // Find max value when there is one element in tree.
    @Test void maxTest2(){
        BinaryTree<Integer> binaryTree = new BinaryTree<>();
        binaryTree.setRoot(new Node<>(1));
        assertEquals(1, binaryTree.maxValue());
    }
    // Find max value when there is no elements in tree.
    @Test void maxTest3(){
        BinaryTree<Integer> binaryTree = new BinaryTree<>();
        assertEquals(Integer.MIN_VALUE, binaryTree.maxValue());
    }
}

class breadthFirst{
    BinaryTree<Integer> binaryTree = new BinaryTree<>();

    @BeforeEach
    void init() {

        binaryTree.setRoot(new Node<>(1));
        binaryTree.getRoot().setLeftChild(new Node<>(2));
        binaryTree.getRoot().setRightChild(new Node<>(3));
        binaryTree.getRoot().getLeftChild().setLeftChild(new Node<>(4));
        binaryTree.getRoot().getLeftChild().setRightChild(new Node<>(5));
        binaryTree.getRoot().getRightChild().setRightChild(new Node<>(6));
    }
    @Test void breadthFirst(){
        ArrayList arrayList = new ArrayList();
        arrayList.add(1);
        arrayList.add(2);
        arrayList.add(3);
        arrayList.add(4);
        arrayList.add(5);
        arrayList.add(6);
        assertEquals(arrayList, binaryTree.breadthFirst(binaryTree));
    }

    @Test void nullTest(){
        BinaryTree<Integer> binaryTree2 = new BinaryTree<>();

        Throwable exception = assertThrows(NullPointerException.class, () -> binaryTree2.breadthFirst(binaryTree2));
    }

    @Test void characterTest(){
        BinaryTree<String> binaryTree2 = new BinaryTree<>();
        binaryTree2.setRoot(new Node<>("A"));
        binaryTree2.getRoot().setLeftChild(new Node<>("B"));
        binaryTree2.getRoot().setRightChild(new Node<>("C"));
        binaryTree2.getRoot().getLeftChild().setLeftChild(new Node<>("D"));
        binaryTree2.getRoot().getLeftChild().setRightChild(new Node<>("E"));
        binaryTree2.getRoot().getRightChild().setRightChild(new Node<>("F"));
        ArrayList arrayList = new ArrayList();
        arrayList.add("A");
        arrayList.add("B");
        arrayList.add("C");
        arrayList.add("D");
        arrayList.add("E");
        arrayList.add("F");
        assertEquals(arrayList, binaryTree2.breadthFirst(binaryTree2));
    }

    @Test
    void oddSumTest(){
        BinaryTree<Integer> binaryTree2 = new BinaryTree<>();
            binaryTree2.setRoot(new Node<>(1));
            binaryTree2.getRoot().setLeftChild(new Node<>(2));
            binaryTree2.getRoot().setRightChild(new Node<>(3));
        binaryTree2.getRoot().getLeftChild().setLeftChild(new Node<>(4));
        binaryTree2.getRoot().getLeftChild().setRightChild(new Node<>(5));
        binaryTree2.getRoot().getRightChild().setRightChild(new Node<>(6));
        binaryTree2.getRoot().getRightChild().setLeftChild(new Node<>(6));
        assertEquals(true, binaryTree.compareLeaves(binaryTree.getRoot(),binaryTree2.getRoot()));
    }
}